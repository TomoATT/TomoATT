version: 3

#################################################
#            computational domian               #
#################################################
domain:
  min_max_dep : [-50.0, 550.0] # depth in km with R = 6371.0
  min_max_lat : [10.5,22.5]    # latitude in degree
  min_max_lon : [95.5,107.5]    # longitude in degree
  n_rtp : [81,81,81]           # number of nodes

#################################################
#            traveltime data file path          #
#################################################
source:
  src_rec_file: OUTPUT_FILES/OUTPUT_FILES_signal_upwind/src_rec_file_forward.dat # source receiver file path
  swap_src_rec: false # swap source and receiver

#################################################
#            initial model file path            #
#################################################
model:
  init_model_path: models/model_init_N81_81_81.h5 # path to initial model file 

#################################################
#            parallel computation settings      #
#################################################
parallel: # parameters for parallel computation
  n_sims: 8 # number of simultanoues runs (parallel the sources)
  ndiv_rtp: [1, 1, 1] # number of subdivision on each direction (parallel the computional domain)

############################################
#            output file setting           #
############################################
output_setting:
  output_dir: OUTPUT_FILES/OUTPUT_FILES_tele_inv_upwind # path to output director (default is ./OUTPUT_FILES/)                                       
  output_final_model:      true # output merged final model (final_model.h5) or not.                                
  output_in_process:       true # output model at each inv iteration or not.                       
  output_in_process_data:  true # output src_rec_file at each inv iteration or not.                                          
  output_file_format: 0

#################################################
#          inversion or forward modeling        #
#################################################
# run mode
# 0 for forward simulation only,
# 1 for inversion
# 2 for earthquake relocation
# 3 for inversion + earthquake relocation
run_mode: 1

###################################################
#          model update parameters setting        #
###################################################
model_update:
  max_iterations: 40 # maximum number of inversion iterations
  
  step_length: 0.02 # initial step length of model perturbation. 0.01 means maximum 1% perturbation for each iteration.

  # parameters for optim_method 0 (gradient_descent)
  optim_method_0:
    step_method: 0  # the method to modulate step size. 0: according to objective function; 1: according to gradient direction 
    # if step_method:0. if objective function increase, step size -> step length * step_length_decay. 
    step_length_decay: 0.9 # default: 0.9

  # parameters for smooth method 0 (multigrid model parametrization)
  # inversion grid can be viewed in OUTPUT_FILES/inversion_grid.txt
  n_inversion_grid: 5 # number of inversion grid sets

  # settings for flexible inversion grid
  dep_inv: [-50, -25.0, 0.0, 50.0, 100.0, 150.0, 200.0, 275.0, 350.0, 425.0, 500.0, 600.0] # inversion grid for vel in depth (km)
  lat_inv: [ 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5, 19.5, 20.5, 21.5, 22.5, 23.5] # inversion grid for vel in latitude (degree)
  lon_inv: [94.5, 95.5, 96.5, 97.5, 98.5, 99.5,100.5,101.5,102.5,103.5,104.5,105.5,106.5,107.5,108.5] # inversion grid for vel in longitude (degree)
  trapezoid: [1, 0, 500]  # usually set as [1.0, 0.0, 50.0] (default)


  # Carefully change trapezoid and trapezoid_ani, if you really want to use trapezoid inversion grid, increasing the inversion grid spacing with depth to account for the worse data coverage in greater depths.
  # The trapezoid_ inversion grid with index (i,j,k) in longitude, latitude, and depth is defined as:
  # if                 dep_inv[k] < trapezoid[1], lon = lon_inv[i];                   
  #                                               lat = lat_inv[j];              
  #                                               dep = dep_inv[k];
  # if trapezoid[1] <= dep_inv[k] < trapezoid[2], lon = mid_lon_inv+(lon_inv[i]-mid_lon_inv)*(dep_inv[k]-trapezoid[1])/(trapezoid[2]-trapezoid[1])*trapezoid[0]; 
  #                                               lat = mid_lat_inv+(lat_inv[i]-mid_lat_inv)*(dep_inv[k]-trapezoid[1])/(trapezoid[2]-trapezoid[1])*trapezoid[0]; 
  #                                               dep = dep_inv[k];
  # if trapezoid[2] <= dep_inv[k],                lon = mid_lon_inv+(lon_inv[i]-mid_lon_inv)*trapezoid[0]; 
  #                                               lat = mid_lat_inv+(lat_inv[i]-mid_lat_inv)*trapezoid[0]; 
  #                                               dep = dep_inv[k];
  # The shape of trapezoid inversion gird (x) looks like:
  #
  #                                 lon_inv[0]   [1]      [2]      [3]      [4]
  #                                  |<-------- (lon_inv[end] - lon_inv[0]) ---->|   
  #  dep_inv[0]                      |   x        x        x        x        x   |   
  #                                  |                                           |   
  #  dep_inv[1]                      |   x        x        x        x        x   |   
  #                                  |                                           |   
  #  dep_inv[2] = trapezoid[1]      /    x        x        x        x        x    \ 
  #                                /                                               \ 
  #  dep_inv[3]                   /    x         x         x         x         x    \ 
  #                              /                                                   \ 
  #  dep_inv[4] = trapezoid[2]  /    x          x          x          x          x    \ 
  #                            |                                                       | 
  #  dep_inv[5]                |     x          x          x          x          x     |  
  #                            |                                                       |  
  #  dep_inv[6]                |     x          x          x          x          x     |  
  #                            |<---- trapezoid[0]* (lon_inv[end] - lon_inv[0]) ------>|  

  # path to station correction file (under development)
  use_sta_correction: false
  # sta_correction_file: dummy_sta_correction_file  # station correction file path
  step_length_sc: 0.001 # step length relate to the update of station correction terms


  # In the following data subsection, XXX_weight means a weight is assigned to the data, influencing the objective function and gradient
  # XXX_weight : [d1,d2,w1,w2] means: 
  # if       XXX < d1, weight = w1 
  # if d1 <= XXX < d2, weight = w1 + (XXX-d1)/(d2-d1)*(w2-w1),  (linear interpolation) 
  # if d2 <= XXX     , weight = w2 
  # You can easily set w1 = w2 = 1.0 to normalize the weight related to XXX.
  # -------------- using absolute traveltime data --------------
  abs_time:
    use_abs_time: false # 'true' for using absolute traveltime data to update model parameters; 'false' for not using (no need to set parameters in this section)

  # -------------- using common source differential traveltime data --------------
  cs_dif_time:
    use_cs_time: true # 'true' for using common source differential traveltime data to update model parameters; 'false' for not using (no need to set parameters in this section)

  # -------------- using common receiver differential traveltime data --------------
  cr_dif_time:
    use_cr_time: false # 'true' for using common receiver differential traveltime data to update model parameters; 'false' for not using (no need to set parameters in this section)

  # -------------- inversion parameters --------------
  update_slowness : true # update slowness (velocity) or not.              default: true
  update_azi_ani  : false # update azimuthal anisotropy (xi, eta) or not.   default: false
